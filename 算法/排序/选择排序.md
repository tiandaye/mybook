## 原理

选择排序(Selection Sort)。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始(末尾)位置，然后在剩下的数当中再找最小(或最大)的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。选择排序是 **不稳定** 的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）【一句话概括：每次从剩下的元素中选择最小的数】

在要排序的一组数中，选出最小的一个数与第一个位置的数交换。然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。

**不稳定的排序方法**，那我们的冒泡排序是不是稳定的排序方法呢【**冒泡是稳定的**】？稳定的意思指的是什么呢？

判断某排序算法是否稳定，我们可以简单理解成：排序前2个相等的数其在序列的 **前后位置顺序和排序后它们两个的前后位置顺序相同**

*   如果相同，则是稳定的排序方法。
*   如果不相同，则是不稳定的排序方法

如果排序前的数组是`[3,3,1]`，假定我们使用选择排序的话，那第一趟排序后结果就是`[1,3,3]`。这个数组有两个相同的值，它俩在`array[0]`和`array[1]`，结果经过排序，`array[0]`的跑到了`array[2]`上了。

那么这就导致：**2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序不相同**，因此，我们就说它是不稳定的。

**那么稳定排序的好处是什么？**

> 如果我们只对一串数字排序，那么稳定与否确实不重要，因为一串数字的属性是单一的，就是数字值的大小。但是排序的元素往往不只有一个属性，例如我们对一群人按年龄排序，但是人除了年龄属性还有身高体重属性，在年龄相同时如果不想破坏原先身高体重的次序，就必须用稳定排序算法.

## 算法描述

思路：

*   【以找最大值举例】一个数组是需要`n-1`趟排序的(因为直到剩下一个元素时，才不需要找最大值)
*   **每交换1次，再次找最大值时就将范围缩小1**
*   查询当前趟数最大值实际上不用知道最大值是多少(上面我查出最大值，还要我手动数它的角标)，**知道它的数组角标即可**，交换也是根据角标来进行交换

代码实现要点：

*   **两个for循环，外层循环控制排序的趟数，内层循环找到当前趟数的最大值，随后与当前趟数组最后的一位元素交换**

## 时间复杂度

O(logN*N)

## 代码实现

### java代码实现

```java
/**
 * 选择排序
 *
 * @param a
 */
public static void selectionSort(int[] a) {
	int len = a.length;
	int flag;

	// 需要做len - 1趟
	for (int i = 0; i < len - 1; i++) {
		flag = i;
		// 选最小的记录
		for (int j = i + 1; j < len; j++) {
			if (a[flag] > a[j]) {
				// 记下目前找到的最小值所在的位置
				flag = j;
			}
		}

		// 在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
		if (flag != i) {
			int temp = a[i];
			a[i] = a[flag];
			a[flag] = temp;
		}
	}
}
```

### php代码实现

```php
function select_sort($arr)
{
    // 双重循环完成, 外层控制轮数, 内层控制比较次数
    $count = count($arr);
    for ($i = 0; $i < $count; $i++) {
        // 先假设最小的值的位置
        $k = $i;

        // 和剩下的元素进行比较, 找到最小的值
        for ($j = $i + 1; $j < $count; $j++) {
            // $arr[$k] 是当前已知的最小值
            if ($arr[$j] < $arr[$k]) {
                // 和剩下的二元素进行比较, 发现更小的值, 则记录下最小值的位置;并且在下次比较时采用已知的最小值进行比较。
                $k = $j;
            }
        }
        // 已经确定了当前的最小值的位置, 保存到$k中。如果发现最小值的位置与当前假设的位置$i不同, 则位置互换即可。
        if ($k != $i) {
            $tmp = $arr[$k];
            $arr[$k] = $arr[$i];
            $arr[$i] = $tmp;
        }
    }
    // 返回最终结果
    return $arr;
}
```

### python代码实现

```python
# 查找数组中最小元素的函数
def findSmallest(arr):
    # 存储最小的值
    smallest = arr[0]
    # 存储最小元素的索引
    smallest_index = 0
    # 从1开始循环
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest = findSmallest(arr)
        # 找出最小的元素加入到新的数组中
        newArr.append(arr.pop(smallest))
    return newArr

print(selectionSort([5, 3, 89, 99, 1]))
```
