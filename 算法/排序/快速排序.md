## 原理

快速排序（Quick Sort）的思想是 **分冶法**

**说明：**通过设置一个初始基准数【一般取第0个】，来将需要排序的数组分成3部分，小于基准数的左边，基准数，大于基准数的右边，继续递归用相同的方式来排序左边和右边，最后合并数组【取数组基准数->遍历数组剩余元素->小于基准数的放左边，大于基准数的放右边->将左右循环如此直至不可再分->将已排好的合并】

**思路：**思路1在php中可以新开两个数组分别存小于基准数的数字和大于基准数的数字。思路2运用交换，将基准数换到中间，从 **右** 往 **左** 找到小于基准数的数【哨兵j】，再从 **左** 往 **右** 找到大于基准数的数【哨兵i】，然后交换它们，直到两个哨兵相遇，将基准数和当前位置i进行交换。

## 算法描述

思路：

*   在数组中找一个元素(节点)，比它小的放在节点的左边，比它大的放在节点右边。一趟下来，比节点小的在左边，比节点大的在右边。
*   不断执行这个操作....

代码实现：

*   快速排序用递归比较好写。支点取中间，使用L和R表示数组的最小和最大位置
    *   不断进行比较，直到找到比支点小(大)的数，随后交换，不断减小范围～
*   递归L到支点前一个元素(j)(执行相同的操作,同上)
*   递归支点后一个元素(i)到R元素(执行相同的操作,同上)

## 时间复杂度

| worst time complexity(最差时间复杂度)   | O(N*N)                                                       |
| --------------------------------------- | ------------------------------------------------------------ |
| Average time complexity(平均时间复杂度) | O(nlog n)                                                    |
| Space time complexity(空间复杂度)       | 最好情况，递归树的深度为logn，空间复杂度也就是O(nlogn)；最坏情况下，需要进行 n-1次递归，其空间复杂度为O(n)；平均情况，空间复杂度为O(nlogn)。 |

## 代码实现

### java实现

```java
public static void quickSort2(int[] a, int left, int right) {
	// 递归结束
	if (left > right) {
		return;
	}

	// 第一个元素当做基准数
	int mid = a[left];
	int i = left;
	int j = right;

	while (i != j) {
		// 从表的两端交替向中间扫描
		// 从右边找比基准值小的值, 带上i < j很重要
		while (a[j] >= mid && i < j) {
			j--;
		}

		// 从左边找比基准值大的值, 带上i < j很重要
		while (a[i] <= mid && i < j) {
			i++;
		}

		// 交换两个数在数组中的位置, 带上i < j很重要表示哨兵i和j没有相遇
		if (i < j) {
			int temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}

	a[left] = a[i];
	a[i] = mid;

	// 继续处理左边的
	quickSort2(a, left, i - 1);
	// 继续处理右边的
	quickSort2(a, i + 1, right);

	return;
}
```

### php实现

```php

/**
 * 快排
 *
 * @param $a
 * @return array
 */
function quickSort($a)
{
    // 判断是否需要运行
    $len = count($a);
    if ($len <= 1) {
        return $a;
    }
    $flag = $a[0];
    // 接收小于中间值
    $left = [];
    // 接收大于中间值
    $right = [];
    for ($i = 1; $i < $len; $i++) {
        if ($a[$i] <= $flag) {
            $left[] = $a[$i];
        } else {
            $right[] = $a[$i];
        }
    }

    // 合并排序后的数据，别忘了合并中间值
    return array_merge(quickSort($left), [$flag], quickSort($right));
}
```