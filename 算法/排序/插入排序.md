## 原理

插入排序（Insertion Sort）。插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、长度加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。

## 算法描述

思路：

*   将一个元素插入到已有序的数组中，在初始时未知是否存在有序的数据，因此将元素**第一个元素看成是有序的**【所以从1开始循环】
*   与有序的数组进行比较，**比它大则直接放入，比它小则移动数组元素的位置，找到一个合适的位置插入**
*   当只有一个数时，则不需要插入了，因此需要`n-1`趟排序，比如10个数，需要9趟排序

代码实现：

*   一个for循环内嵌一个while循环实现，外层for循环控制需要排序的趟数，while循环找到合适的插入位置(并且插入的位置不能小于0)

## 时间复杂度

稳定算法
空间复杂度O(1)
时间复杂度O(n*n)
最差情况：反序，需要移动n\*(n-1)/2个元素
最好情况：正序，不需要移动元素

数组在已排序或者是“近似排序”时，插入排序效率的最好情况运行时间为O(n)；

插入排序最坏情况运行时间和平均情况运行时间都为O(n*n)。

通常，插入排序呈现出二次排序算法中的最佳性能。

对于具有较少元素（如n<=15）的列表来说，二次算法十分有效。

在列表已被排序时，插入排序是线性算法O(n)。

在列表“近似排序”时，插入排序仍然是线性算法。

在列表的许多元素已位于正确的位置上时，就会出现“近似排序”的条件。

通过使用O(nlog2n)效率的算法（如快速排序）对数组进行部分排序，

然后再进行选择排序，某些高级的排序算法就是这样实现的。

## 代码实现

### java代码实现

```java
/**
 * 插入排序, 推荐看这个
 *
 * @param a
 */
public static void insertionSort(int[] a) {
	int len = a.length;
	// 临时变量
	int temp;
	// 外层循环控制需要排序的趟数(从1开始因为将第0位看成了有序数据)
	for (int i = 1; i < len; i++) {
		// temp标记为未排序的第一个元素
		temp = a[i];
		// 如果前一位(已排序的数据的最后一位)比当前数据要大，那么就进入循环比较
		int j = i - 1;

		// 将temp与已排序元素(前i个数是有序的)从大到小比较，寻找temp应插入的元素
		while (j >= 0 && a[j] > temp) {
			// 往后退一个位置，让当前数据与之前前位进行比较
			a[j + 1] = a[j];
			// 不断往前，直到退出循环
			j--;
		}
		// 退出了循环说明找到了合适的位置了，将当前数据插入合适的位置中
		a[j + 1] = temp;
	}
}
```

