## 原理

冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。

*   俩俩交换，大的放在后面，第一次排序后最大值已在数组末尾。
*   因为俩俩交换，需要`n-1`趟排序，比如10个数，需要9趟排序

## 算法描述

1.  **`i`从0开始，`i`与`i+1`比较，如果`i>i+1`，那么就互换**
2.  **`i`不断增加，直到`i<n-1`（n是数组元素的个数，`n-1`是数组已经最后一个元素） ，一趟下来，可以让数组元素中最大值排在数组的最后面**

思路：

*   俩俩交换，大的放在后面，第一次排序后最大值已在数组末尾。
*   因为俩俩交换，需要`n-1`趟排序，比如10个数，需要9趟排序

代码实现要点

*   **两个for循环，外层循环控制排序的趟数，内层循环控制比较的次数**
    *   **每趟过后，比较的次数都应该要减1**
*   优化：如果一趟排序后也没有交换位置，那么该数组已有序

## 时间复杂度

O(N*N)

## 代码实现

### java实现

**未优化版本**

```java
/**
 * 冒泡排序
 *
 * @param a
 */
public static void bubbleSort(int[] a) {
	int temp;
	int len = a.length;
	// 外层循环是排序的趟数
	for (int i = 0; i < len - 1; i++) {
		// 内层循环是当前趟数需要比较的次数
		for (int j = 0; j < len - i - 1; j++) {
			// 前一位与后一位与前一位比较，如果前一位比后一位要大，那么交换
			if (a[j] > a[j + 1]) {
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
			}
		}
	}
}
```



**优化版本**

```java
/**
 * 冒泡排序优化版本
 *
 * @param arrays
 */
public static void bubbleSort2(int[] arrays) {
	// 装载临时变量
	int temp;

	// 记录是否发生了置换， 0 表示没有发生置换、 1 表示发生了置换
	int isChange;

	int len = arrays.length;

	// 外层循环是排序的趟数
	for (int i = 0; i < len - 1; i++) {
		// 每比较一趟就重新初始化为0
		isChange = 0;
		// 内层循环是当前趟数需要比较的次数
		for (int j = 0; j < len - i - 1; j++) {
			// 前一位与后一位与前一位比较，如果前一位比后一位要大，那么交换
			if (arrays[j] > arrays[j + 1]) {
				temp = arrays[j];
				arrays[j] = arrays[j + 1];
				arrays[j + 1] = temp;

				// 如果进到这里面了，说明发生置换了
				isChange = 1;
			}
		}
		// 如果比较完一趟没有发生置换，那么说明已经排好序了，不需要再执行下去了
		if (isChange == 0) {
			break;
		}
	}
}
```